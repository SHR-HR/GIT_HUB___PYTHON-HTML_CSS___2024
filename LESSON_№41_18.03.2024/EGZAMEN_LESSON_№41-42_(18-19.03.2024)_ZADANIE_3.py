# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
"""""
Дата выполнения ЭКЗАМЕНАЦИОННОЙ РАБОТЫ: 18 и 19 МАРТА 2024 года.
"""""
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
                                                    ЭКЗАМЕН

                                            Курс: Разработка Web-приложений на Python, с применением Фреймворка Django
                                                                         Дисциплина: Основы программирования на Python

                                            Тема занятия №41-42 : Экзамен


                                            Выполните следующие задания:


Выполните следующие задания:

"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
1. Используйте ООП

Пиццерия предлагает клиентам три вида пиццы: Пепперони, Барбекю и Дары Моря,
каждая из которых определяется тестом, соусом и начинкой.

Требуется спроектировать и реализовать приложение для терминала, позволяющее обеспечить обслуживание посетителей.

Дополнительная информация

В бизнес-процессе работы пиццерии в контексте задачи можно выделить 3 сущности (объекта):

Терминал: отвечает за взаимодействие с пользователем:
вывод меню на экран;
прием команд от пользователя (выбор пиццы, подтверждение заказа, оплата и др.);

Заказ: содержит список заказанных пицц, умеет подсчитывать свою стоимость;

Пицца: содержит заявленные характеристики пиццы, 
а также умеет себя подготовить (замесить тесто, собрать ингредиенты), испечь, порезать и упаковать.

Пиццерия реализует несколько видов пиццы, которые различаются характеристиками, 
логично будет сделать общий класс Пицца, а в дочерних классах (например, классе ПиццаБарбекю) 
уточнить характеристики конкретной пиццы.



Алгоритм работы пользователя с терминалом может выглядеть следующим образом:

Терминал отображает список меню.
Терминал создает новый заказ.
Клиент вводит номер пиццы из меню.
Заказ добавляет в список выбранную пиццу.
Действия 3-4 повторяются до подтверждения или отмены.

Клиент подтверждает заказ (или отменяет).
Терминал выставляет счет, отображая информацию о заказе.
Терминал принимает оплату.
Заказ отдается на выполнение.



"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
2. Используйте процедурное программирование:

Игра: камень, ножницы, бумага.

Алгоритм работы пользователя с терминалом может выглядеть следующим образом:

Поприветствуйте игрока и попросите ввести его.
Получить случайный компьютерный ввод.
Проверьте два друг против друга.
Спросите, хочет ли игрок снова сыграть.



"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
3. Реализуйте следующие игры:

1. Виселица
2. Угадывание числа
3. Викторина
4. Змейка
5. Генератор MadLibs

Помните ту игру, в которую мы играли в детстве? 
Игра, в которой мы вставляли глупые слова в пробелы и истерически смеялись, когда нам их зачитывали?

С генератором Mad Libs вы можете пережить эти весёлые моменты заново.
Этот генератор позволяет вам работать над широким спектром навыков Python. 
Используемые навыки: строки, переменные, конкатенация, печать.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Урок от 18.03.2024
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
                                                        # ЗАДАНИЕ №3
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
'''                                                   1. Виселица                                                    '''
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
import random

def hangman():
    word_list = ["питон", "виселица", "программирование", "код", "функция"]
    chosen_word = random.choice(word_list)
    word_length = len(chosen_word)
    display = ["_"] * word_length
    guesses = set()
    attempts = 6

    print("Добро пожаловать в игру Виселица!")
    print(f"Загаданное слово состоит из {word_length} букв: {' '.join(display)}")

    while attempts > 0 and "_" in display:
        guess = input("Угадайте букву: ").lower()

        if guess in guesses:
            print("Вы уже угадывали эту букву. Попробуйте другую.")
            continue
        guesses.add(guess)

        if guess in chosen_word:
            print("Верно! Буква есть в слове.")
            for i in range(word_length):
                if chosen_word[i] == guess:
                    display[i] = guess
        else:
            attempts -= 1
            print(f"Неверно. Осталось попыток: {attempts}")

        print(f"{' '.join(display)}")

    if "_" not in display:
        print("Поздравляем, вы угадали слово!")
    else:
        print(f"К сожалению, вы проиграли. Загаданное слово было: {chosen_word}")

hangman()

"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
'''
Шаг №1 - Импорт модуля
'''
import random
'''
Описание: 
В самом начале кода происходит импорт модуля random. 
Этот модуль предоставляет функции для генерации случайных чисел, что необходимо для выбора случайного слова из списка.
'''
'''
Шаг №2 - Определение функции hangman
'''
def hangman():
''''
Описание: 
Это основная функция игры "Виселица". 
В ней реализован весь игровой процесс, включая выбор слова, обработку догадок пользователя и отображение результатов.
''''
'''
Шаг №3 - Инициализация переменных
'''
word_list = ["питон", "виселица", "программирование", "код", "функция"]
chosen_word = random.choice(word_list)
word_length = len(chosen_word)
display = ["_"] * word_length
guesses = set()
attempts = 6
'''
Описание:

word_list: Список слов для угадывания.
chosen_word: Случайно выбранное слово из списка word_list.
word_length: Длина выбранного слова.
display: Список, представляющий текущее состояние угаданных букв слова, 
изначально заполненный символами подчеркивания (_), которые будут заменяться на угаданные буквы.
guesses: Множество (set), хранящее все попытки угадать буквы (догадки пользователя).
attempts: Количество попыток, которые остались у пользователя.
'''
'''
Шаг №4 - Приветствие
'''
print("Добро пожаловать в игру Виселица!")
print(f"Загаданное слово состоит из {word_length} букв: {' '.join(display)}")
'''
Описание: 
Выводится приветственное сообщение и информация о длине загаданного слова, а также текущее состояние слова
(все буквы изначально скрыты).
'''
'''
Шаг №5 - Основной игровой цикл
'''
while attempts > 0 and "_" in display:
    guess = input("Угадайте букву: ").lower()
'''
Описание: 
Игра продолжается, пока у пользователя есть попытки и в слове остаются неугаданные буквы.
В каждой итерации цикла запрашивается у пользователя догадка о букве.
'''
'''
Шаг №6 - Проверка догадки
'''
if guess in guesses:
    print("Вы уже угадывали эту букву. Попробуйте другую.")
    continue
guesses.add(guess)
'''
Описание: 
Если пользователь уже предлагал эту букву, выводится предупреждение, 
и цикл продолжается с новой итерации. В противном случае догадка добавляется в множество guesses.
'''
'''
Шаг №7 - Обновление состояния игры
'''
if guess in chosen_word:
    print("Верно! Буква есть в слове.")
    for i in range(word_length):
        if chosen_word[i] == guess:
            display[i] = guess
else:
    attempts -= 1
    print(f"Неверно. Осталось попыток: {attempts}")
'''
Описание: 
Если догадка верна, соответствующие символы подчеркивания в display заменяются на угаданную букву.
В противном случае количество оставшихся попыток уменьшается.
'''
'''
Шаг №8 - Проверка условий победы или поражения
'''
if "_" not in display:
    print("Поздравляем, вы угадали слово!")
else:
    print(f"К сожалению, вы проиграли. Загаданное слово было: {chosen_word}")
'''
Описание: 
После окончания игры проверяется, угадано ли слово полностью. 
Если да, пользователь побеждает, иначе ему сообщается, что он проиграл, и показывается загаданное слово.
'''
'''
Запуск игры
'''
hangman()
'''
Описание: Вызов функции hangman() запускает игру.
'''
'''
Каждый из этих шагов сочетает в себе логические и функциональные аспекты игры "Виселица",
демонстрируя базовые принципы программирования: циклы, условные операторы, ввод/вывод данных и работу с 
коллекциями в Python. Ну чтож, продолжим далее.
'''
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
'''                                                   2. Угадывание числа                                            '''
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
import random

def guess_number():
    print("Добро пожаловать в игру 'Угадай число'!")
    print("Я загадал число между 1 и 100. Попробуйте угадать его как можно меньшим количеством попыток.")

    secret_number = random.randint(1, 100)
    attempts = 0

    while True:
        guess = input("Введите число: ")
        if not guess.isdigit():
            print("Пожалуйста, введите целое число.")
            continue

        guess = int(guess)
        attempts += 1

        if guess < secret_number:
            print("Слишком маленькое число.")
        elif guess > secret_number:
            print("Слишком большое число.")
        else:
            print(f"Поздравляем! Вы угадали число {secret_number} с {attempts} попыток.")
            break

guess_number()
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
'''
Шаг №1 - Импорт модуля
'''
import random
'''
Описание: 
В начале кода происходит импорт модуля random, который используется для генерации случайных чисел.
В этой игре он необходим для определения загаданного числа.
'''
'''
Шаг №2 - Определение функции guess_number
'''
def guess_number():
''''
Описание: 
Определяется функция guess_number, которая не принимает аргументов и описывает логику игры "Угадай число".
Вся игра будет происходить внутри этой функции.
''''
'''
Шаг №3 - Приветствие и объявление правил игры
'''
print("Добро пожаловать в игру 'Угадай число'!")
print("Я загадал число между 1 и 100. Попробуйте угадать его как можно меньшим количеством попыток.")
'''
Описание: 
Выводятся приветственное сообщение и правила игры. Игроку сообщается, что было загадано число между 1 и 100,
и его задача - угадать это число.
'''
'''
Шаг №4 - Генерация загаданного числа и инициализация счетчика попыток
'''
secret_number = random.randint(1, 100)
attempts = 0
'''
Описание:

secret_number: С помощью функции random.randint(1, 100) генерируется случайное число от 1 до 100 включительно,
которое игрок должен угадать.
attempts: Инициализируется переменная attempts, отслеживающая количество попыток пользователя.
'''
'''
Шаг №5 - Основной игровой цикл
'''
while True:
    guess = input("Введите число: ")
'''
Описание: 
Начинается бесконечный цикл, в котором игроку предлагается ввести число через консоль.
Этот цикл будет прерван, когда игрок угадает число.
'''
'''
Шаг №6 - Проверка ввода
'''
if not guess.isdigit():
    print("Пожалуйста, введите целое число.")
    continue
'''
Описание: 
Проверяется, является ли введенное значение числом с помощью метода isdigit(). 
Если нет, игроку предлагается ввести целое число, и цикл продолжается без увеличения счетчика попыток.
'''
'''
Шаг №7 - Сравнение введенного числа с загаданным
'''
guess = int(guess)
attempts += 1

if guess < secret_number:
    print("Слишком маленькое число.")
elif guess > secret_number:
    print("Слишком большое число.")
else:
    print(f"Поздравляем! Вы угадали число {secret_number} с {attempts} попыток.")
    break
'''
Описание:
Введенное значение преобразуется в целое число.
Счетчик попыток увеличивается.
Если введенное число меньше загаданного, игроку сообщается, что число слишком маленькое.
Если введенное число больше загаданного, игроку сообщается, что число слишком большое.
Если число угадано, выводится поздравление с указанием загаданного числа и количества попыток. 
Цикл прерывается с помощью break.
'''
'''
Запуск игры
'''
guess_number()
'''
Описание: Вызов функции guess_number() инициирует начало игры.
'''
'''
Продолжаем
'''
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
'''                                                     3. Викторина                                                 '''
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
def quiz_game():
    questions = {
        "Столица Франции: ": "A",
        "2 + 2 * 2 = ": "B",
        "Самая длинная река в мире: ": "C"
    }
    options = [
        ["A. Марсель", "B. Лион", "C. Париж"],
        ["A. 6", "B. 8", "C. 4"],
        ["A. Амазонка", "B. Нил", "C. Янцзы"]
    ]
    correct_answers = {
        "Столица Франции: ": "C. Париж",
        "2 + 2 * 2 = ": "B. 8",
        "Самая длинная река в мире: ": "A. Амазонка"
    }

    score = 0

    print("Добро пожаловать в Викторину!")

    for i, (question, options_list) in enumerate(zip(questions.keys(), options)):
        print(question)
        for option in options_list:
            print(option)
        user_input = input("Введите ответ (A, B, C или полный ответ): ").upper().strip()

        correct_option = correct_answers[question].split('. ')[0]


        if user_input == correct_option or user_input in correct_answers[question].upper():
            print("Правильно!")
            score += 1
        else:
            print(f"Неправильно. Правильный ответ: {correct_answers[question]}")

    print(f"Ваш итоговый счет: {score} из {len(questions)}")


quiz_game()
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
'''
Шаг №1 - Определение функции quiz_game
'''
def quiz_game():
''''
Описание: 
Это объявление функции quiz_game, которая не принимает аргументов. 
В этой функции реализована логика викторины, включая задание вопросов, проверку ответов и подсчет результатов.
''''
'''
Шаг №2 - Инициализация данных викторины
'''
questions = {...}
options = [...]
correct_answers = {...}
'''
Описание: В этих структурах данных хранится информация о викторине:

questions: словарь с вопросами и буквенными обозначениями правильных ответов (для внутреннего использования).
options: список списков с вариантами ответов для каждого вопроса, которые будут показаны пользователю.
correct_answers: словарь с вопросами и полными формулировками правильных ответов для отображения в конце.
'''
'''
Шаг №3 - Начальная настройка и приветствие
'''
score = 0
print("Добро пожаловать в Викторину!")
'''
Описание: 
Инициализируется переменная score, отслеживающая количество правильных ответов пользователя. 
Затем выводится приветственное сообщение.
'''
'''
Шаг №4 - Основной цикл викторины
'''
for i, (question, options_list) in enumerate(zip(questions.keys(), options)):
'''
Описание: 
Цикл перебирает все вопросы и соответствующие им варианты ответов. 
Используется функция enumerate для получения индекса каждого вопроса и функция zip для объединения вопросов 
и вариантов ответов в пары.
'''
'''
Шаг №5 - Вывод вопросов и вариантов ответа
'''
print(question)
for option in options_list:
    print(option)
'''
Описание: 
Внутри цикла для каждого вопроса сначала выводится сам вопрос, а затем все доступные варианты ответа.
'''
'''
Шаг №6 - Получение и обработка ответа пользователя
'''
user_input = input("Введите ответ (A, B, C или полный ответ): ").upper().strip()
'''
Описание: 
Пользователю предлагается ввести ответ. 
Ввод приводится к верхнему регистру и обрезаются пробельные символы по краям для унификации обработки.
'''
'''
Шаг №7 - Проверка ответа
'''
if user_input == correct_option or user_input in correct_answers[question].upper():
'''
Описание: 
Проверяется, совпадает ли ответ пользователя с буквенным обозначением правильного ответа или с 
полным текстом правильного ответа (независимо от регистра).
'''
'''
Шаг №8 - Вывод результата и подсчет очков
'''
if ...:
    print("Правильно!")
    score += 1
else:
    print(f"Неправильно. Правильный ответ: {correct_answers[question]}")

'''
Описание: 
Если ответ правильный, пользователю выводится сообщение о правильности ответа, 
и количество очков увеличивается. В противном случае пользователю показывается правильный ответ.
'''
'''
Шаг №9 - Итоговый результат
'''
print(f"Ваш итоговый счет: {score} из {len(questions)}")
'''
Описание: 
По завершению викторины выводится итоговый счет пользователя: 
сколько вопросов было отвечено правильно из общего числа.
'''
'''
Запуск игры
'''
quiz_game()
'''
Описание: Вызов функции quiz_game() запускает игру.
'''
'''
Нет поводов для отдыха и остановки - продолжим....... фигачить :D
'''
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
'''                                                     4. Змейка                                                    '''
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
                                                    pip install pygame
                                        python.exe -m pip install --upgrade pip
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
import pygame
import time
import random

pygame.init()

white = (255, 255, 255)
black = (0, 0, 0)
red = (213, 50, 80)
green = (0, 255, 0)
blue = (50, 153, 213)

dis_width = 600
dis_height = 400
dis = pygame.display.set_mode((dis_width, dis_height))
pygame.display.set_caption('Змейка')

clock = pygame.time.Clock()
snake_block = 10
snake_speed = 15

font_style = pygame.font.SysFont(None, 35)

def our_snake(snake_block, snake_list):
    for x in snake_list:
        pygame.draw.rect(dis, black, [x[0], x[1], snake_block, snake_block])

def message(msg, color):
    mesg = font_style.render(msg, True, color)
    dis.blit(mesg, [dis_width / 6, dis_height / 3])

def gameLoop():
    game_over = False
    game_close = False

    x1 = dis_width / 2
    y1 = dis_height / 2

    x1_change = 0
    y1_change = 0

    snake_list = []
    length_of_snake = 1

    foodx = round(random.randrange(0, dis_width - snake_block) / 10.0) * 10.0
    foody = round(random.randrange(0, dis_height - snake_block) / 10.0) * 10.0

    while not game_over:

        while game_close:
            dis.fill(blue)
            message("You lost! Press C-Play Again or Q-Quit", red)
            pygame.display.update()

            for event in pygame.event.get():
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_q:
                        game_over = True
                        game_close = False
                    if event.key == pygame.K_c:
                        gameLoop()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                game_over = True
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_LEFT:
                    x1_change = -snake_block
                    y1_change = 0
                elif event.key == pygame.K_RIGHT:
                    x1_change = snake_block
                    y1_change = 0
                elif event.key == pygame.K_UP:
                    y1_change = -snake_block
                    x1_change = 0
                elif event.key == pygame.K_DOWN:
                    y1_change = snake_block
                    x1_change = 0

        if x1 >= dis_width or x1 < 0 or y1 >= dis_height or y1 < 0:
            game_close = True
        x1 += x1_change
        y1 += y1_change
        dis.fill(blue)
        pygame.draw.rect(dis, green, [foodx, foody, snake_block, snake_block])
        snake_head = []
        snake_head.append(x1)
        snake_head.append(y1)
        snake_list.append(snake_head)
        if len(snake_list) > length_of_snake:
            del snake_list[0]

        for x in snake_list[:-1]:
            if x == snake_head:
                game_close = True

        our_snake(snake_block, snake_list)
        pygame.display.update()

        if x1 == foodx and y1 == foody:
            foodx = round(random.randrange(0, dis_width - snake_block) / 10.0) * 10.0
            foody = round(random.randrange(0, dis_height - snake_block) / 10.0) * 10.0
            length_of_snake += 1

        clock.tick(snake_speed)

    pygame.quit()
    quit()

gameLoop()
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
'''
Шаг №1 - Импорт библиотек
'''
import pygame
import time
import random
'''
Описание: 
Импортируются необходимые модули. pygame для создания игры, 
time не используется в данном коде и может быть исключен, 
random используется для генерации случайных позиций еды на игровом поле.
'''
'''
Шаг №2 - Инициализация Pygame и настройка дисплея
'''
pygame.init()

dis_width = 600
dis_height = 400
dis = pygame.display.set_mode((dis_width, dis_height))
pygame.display.set_caption('Змейка')
'''
Описание: 
Инициализируется Pygame. Задаются ширина и высота игрового окна, 
создается окно игры с помощью pygame.display.set_mode, и устанавливается заголовок окна.
'''
'''
Шаг №3 - Определение цветов и параметров змейки
'''
white = (255, 255, 255)
...
blue = (50, 153, 213)

snake_block = 10
snake_speed = 15
'''
Описание: 
Определяются цвета в формате RGB, используемые в игре, а также размер блока змейки и скорость змейки.
'''
'''
Шаг №4 - Создание функций для змейки и сообщений
'''
def our_snake(snake_block, snake_list):
    ...

def message(msg, color):
    ...
'''
Описание: 
our_snake рисует змейку на экране, используя список координат ее сегментов. message выводит сообщения на экран.
'''
'''
Шаг №5 - Главный игровой цикл
'''
def gameLoop():
    ...
'''
Описание: 
Функция gameLoop содержит основной игровой цикл, управляющий игровыми событиями, такими как движение змейки,
съедание еды и проверку на столкновения.
'''
'''
Шаг №6 - Обработка событий клавиатуры
'''
for event in pygame.event.get():
    if event.type == pygame.KEYDOWN:
        ...
'''
Описание: 
В этом блоке кода обрабатываются события нажатия клавиш для управления направлением движения змейки.
'''
'''
Шаг №7 - Проверка столкновений
'''
if x1 >= dis_width or x1 < 0 or y1 >= dis_height or y1 < 0:
    game_close = True
'''
Описание: 
Проверяется, не вышла ли змейка за пределы игрового поля.
'''
'''
Шаг №8 - Рост змейки и генерация еды
'''
if x1 == foodx and y1 == foody:
    ...
'''
Описание: 
Если змейка съедает еду, ее длина увеличивается, и на игровом поле генерируется новая еда.
'''
'''
Шаг №9 - Окончание игры
'''
while game_close:
    ...
'''
Описание: 
Если игра окончена (столкновение со стеной или самой себя), выводится сообщение о проигрыше и предлагается начать
игру заново или выйти.
'''
'''
Шаг №10 - Обновление экрана и контроль FPS
'''
pygame.display.update()
clock.tick(snake_speed)
'''
Описание: 
Экран обновляется для отображения изменений, а clock.tick(snake_speed) контролирует скорость обновления экрана,
делая движение змейки плавным.
'''
'''
Шаг №11 - Завершение Pygame
'''
pygame.quit()
quit()
'''
Описание: 
После выхода из игрового цикла (когда игра окончена и пользователь решает не начинать заново) 
Pygame завершает работу, и программа закрывается.
'''
'''
Запуск игры
'''
gameLoop()
'''
Описание: 
Вызов функции gameLoop() запускает игру "Змейка".
'''
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
'''                                                ВАРИАНТ ПОПРОЩЕ (Змейка)                                          '''
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
import random
import os
import time


width = 20
height = 10
x, y = width // 2, height // 2
game_over = False
trail = []
tail_length = 5



def print_field(x, y, trail):
    os.system('cls' if os.name == 'nt' else 'clear')
    for row in range(height):
        for col in range(width):
            if (col, row) == (x, y):
                print("O", end="")
            elif (col, row) in trail:
                print("*", end="")
            else:
                print(" ", end="")
        print()



while not game_over:
    direction = input("Введите направление (w/s/a/d): ").lower()
    if direction == "w":
        y -= 1
    elif direction == "s":
        y += 1
    elif direction == "a":
        x -= 1
    elif direction == "d":
        x += 1


    game_over = x < 0 or x >= width or y < 0 or y >= height
    head = (x, y)
    trail.append(head)
    trail = trail[-tail_length:]

    print_field(x, y, trail)
    time.sleep(0.2)  # Задержка для удобства восприятия

if game_over:
    print("Игра окончена!")
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
'''
Шаг №1 - Импорт модулей
'''
import random
import os
import time
'''
Описание: 
Импортируются необходимые модули. random в данном коде не используется и может быть исключен.
os используется для очистки консоли, а time - для добавления задержки между ходами.
'''
'''
Шаг №2 - Инициализация начальных параметров
'''
width = 20
height = 10
x, y = width // 2, height // 2
game_over = False
trail = []
tail_length = 5
'''
Описание: 
Задаются начальные параметры игрового поля, начальная позиция символа, флаг окончания игры, 
список для хранения "следа" символа и длина этого следа.
'''
'''
Шаг №3 - Функция для отображения игрового поля
'''
def print_field(x, y, trail):
    ...
'''
Описание: 
Функция print_field очищает экран и отображает игровое поле, где "O" - это текущая позиция символа,
"*" - части следа символа, а пробелы обозначают пустое пространство.
'''
'''
Шаг №4 - Главный игровой цикл
'''
while not game_over:
    ...
'''
Описание: 
В бесконечном цикле игрок вводит направление движения символа (w, s, a, d), после чего происходит обновление позиции.
Цикл завершается, когда символ выходит за границы игрового поля.
'''
'''
Шаг №5 - Обработка ввода пользователя
'''
direction = input("Введите направление (w/s/a/d): ").lower()
'''
Описание: 
Запрашивается и обрабатывается ввод направления от пользователя. 
В зависимости от введенной команды обновляются координаты символа.
'''
'''
Шаг №6 - Проверка на выход за границы
'''
game_over = x < 0 or x >= width or y < 0 or y >= height
'''
Описание: 
Если символ выходит за границы игрового поля, игра заканчивается.
'''
'''
Шаг №7 - Обновление следа символа
'''
head = (x, y)
trail.append(head)
trail = trail[-tail_length:]
'''
Описание: 
Текущая позиция добавляется в список следа, а список обрезается до заданной длины, чтобы сохранить 
только последние позиции.
'''
'''
Шаг №8 - Отображение поля и задержка
'''
print_field(x, y, trail)
time.sleep(0.2)
'''
Описание: 
Вызывается функция отображения поля с текущим состоянием следа, после чего добавляется кратковременная 
задержка для удобства восприятия изменений на поле.
'''
'''
Шаг №9 - Сообщение об окончании игры
'''
if game_over:
    print("Игра окончена!")
'''
Описание: После выхода из цикла, если игра окончена, выводится сообщение об этом.
'''
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
'''                                                5. Генератор MadLibs                                              '''
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
# Приветствие
print("Добро пожаловать в игру MadLibs!")
print("Ответьте на следующие вопросы, чтобы создать свою собственную забавную историю.")


существительное = input("Введите существительное: ")
прилагательное1 = input("Введите прилагательное: ")
прилагательное2 = input("Введите еще одно прилагательное: ")
глагол = input("Введите глагол в прошедшем времени: ")
место = input("Введите место: ")


история = f"Однажды, мое {существительное} очень {прилагательное1} проснулось. " \
          f"Оно решило {глагол} за пределы дома. " \
          f"Когда мы приехали в {место}, мы увидели {прилагательное2} пейзаж. " \
          f"Это был незабываемый день!"

# Вывод истории
print("\nВаша MadLibs история:")
print(история)
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
'''
Шаг №1 - Приветствие
'''
print("Добро пожаловать в игру MadLibs!")
print("Ответьте на следующие вопросы, чтобы создать свою собственную забавную историю.")
'''
Описание: В начале пользователь приветствуется и получает инструкции о том, что ему предстоит делать.
'''
'''
Шаг №2 - Запрос ввода от пользователя
'''
существительное = input("Введите существительное: ")
прилагательное1 = input("Введите прилагательное: ")
прилагательное2 = input("Введите еще одно прилагательное: ")
глагол = input("Введите глагол в прошедшем времени: ")
место = input("Введите место: ")
'''
Описание: 
Пользователю предлагается ввести различные слова по категориям (существительное, прилагательные, глагол, место),
которые будут использоваться для заполнения шаблона истории.
'''
'''
Шаг №3 - Создание истории
'''
история = f"Однажды, мое {существительное} очень {прилагательное1} проснулось. " \
          f"Оно решило {глагол} за пределы дома. " \
          f"Когда мы приехали в {место}, мы увидели {прилагательное2} пейзаж. " \
          f"Это был незабываемый день!"
'''
Описание: 
С помощью строковой интерполяции (f-строк) введенные пользователем слова вставляются в шаблон истории,
создавая уникальный рассказ.
'''
'''
Шаг №4 - Вывод истории
'''
print("\nВаша MadLibs история:")
print(история)
'''
Описание: История, созданная на основе ввода пользователя, выводится на экран.
'''
'''
Как я понял из форума хабр-хабр, игры MadLibs популярны как образовательные инструменты,
помогающие детям учиться частям речи, а также как просто забавное развлечение для людей всех возрастов.
Этот код демонстрирует основы ввода/вывода в Python, работу со строками и простую интерактивность.
'''
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
'''                                     Вариант игры "Здесь и Сейчас" для MadLibs:                                   '''
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
print("Добро пожаловать в игру MadLibs 'Здесь и Сейчас'!")
print("Заполните пропуски, чтобы создать смешную историю.")


технология = input("Назовите технологию или приложение: ")
знаменитость = input("Назовите знаменитость: ")
действие = input("Введите глагол (что делает?): ")
предмет = input("Введите предмет (что-то конкретное): ")
емотикон = input("Введите ваш любимый эмодзи: ")
город = input("Назовите город: ")
музыкальная_группа = input("Назовите музыкальную группу или исполнителя: ")
хэштег = input("Придумайте хэштег (без #): ")


история = f"Сегодня утром, когда я открыл(а) {технология}, я не поверил(а) своим глазам. " \
          f"Там было объявление о том, что {знаменитость} будет {действие} в центре города {город}! " \
          f"Я сразу же взял(а) свой {предмет} и отправился(лась) туда. " \
          f"Когда я пришел(а), я увидел(а) {емотикон} и услышал(а) живой концерт {музыкальная_группа}. " \
          f"Это был незабываемый день, и я даже сделал(а) пост в соцсетях с хэштегом #{хэштег}."

# Вывод истории
print("\nВаша история 'Здесь и Сейчас':")
print(история)
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
'''
Шаг №1 - Приветствие
'''
print("Добро пожаловать в игру MadLibs 'Здесь и Сейчас'!")
print("Заполните пропуски, чтобы создать смешную историю.")
'''
Описание: 
Игрок приветствуется и получает инструкцию о том, что ему предстоит делать - заполнять пропуски в истории.
'''
'''
Шаг №2 - Запрос ввода от пользователя
'''
технология = input("Назовите технологию или приложение: ")
...
хэштег = input("Придумайте хэштег (без #): ")
'''
Описание: 
Игроку предлагается ввести различные данные: название технологии или приложения, имя знаменитости,
глагол, предмет, эмодзи, город, музыкальную группу и хэштег. 
Эти данные будут использоваться для заполнения пропусков в истории.
'''
'''
Шаг №3 - Создание истории
'''
история = f"Сегодня утром, когда я открыл(а) {технология}, я не поверил(а) своим глазам. " \
          ...
          f"Это был незабываемый день, и я даже сделал(а) пост в соцсетях с хэштегом #{хэштег}."
'''
Описание: 
Используя строковую интерполяцию (f-строки), введенные пользователем данные вставляются в заранее подготовленный
шаблон истории, создавая уникальный и часто забавный рассказ.
'''
'''
Шаг №4 - Вывод истории
'''
print("\nВаша история 'Здесь и Сейчас':")
print(история)
'''
Описание: Сформированная история выводится на экран, предлагая игроку посмотреть на результат его творчества.
'''
"""                              # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #                             """
"""                                              # ~ БЛАГОДАРЮ за ВНИМАНИЕ ~ #                                       """